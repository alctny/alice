#!/bin/bash

# 功能: 將當前目錄下的所有文件（不包含隱藏文件）重命名爲“前綴+index” 的格式
# 參數:
#   -p: 文件名前綴，爲空時格式化之後的結果只有 index
#   -i: 起始序號，默認從 0 開始，且會按照目錄下文件數量自動在前方添加 0
#   -l: 序號長度
# 注意: 此函數不會修改文件的後綴名，但默認了文件的後綴只有一個 .，對於 .tar.gz 的文件會被認爲後綴是 .gz 而不是 .tar.gz
function with_index() {
  # 參數解析kkk
  index=0
  while getopts "p:i:l:" opt; do
    case $opt in
      p)
        prefix="$OPTARG"
        ;;
      i)
        index=$OPTARG
        ;;
      l)
        len=$OPTARG
        ;;
      *)
        echo "unknow arg: $OPTARG"
        ;;
    esac
  done

  # 自適應序號長度
  if [[ -z $len ]]; then
    fcnt=$(( ($(ls | wc -l) + index) / 10 ))
    while true; do
      len=$(( len + 1 ))
      if [ $fcnt -eq 0 ]; then
        break
      fi
      fcnt=$(( fcnt / 10 ))
    done
  fi

  # 文件重命名
  for f in *; do
    surfix=${f##*.}
    idx_str=$(printf "%0${len}d" $index)
    new_name="${p}${idx_str}.${surfix}"
    echo  "${f} -> ${new_name}"
    mv "${f}" "${new_name}"
    index=$(( index + 1 ))
  done
}

# 功能: 批量重命名文件 but 手動檔
function with_bulk() {
  file_list=""

  while getopts "f:" opt; do
    case $opt in
      f) file_list=$OPTARG ;;
    esac
  done

  if [[ "$file_list" == "" ]]; then
    file_list=$(mktemp)
    ls > $file_list
  fi

  if [[ ! -s "$file_list" ]]; then
    echo "nothing to do"
    exit 0
  fi

  bak=$(mktemp)
  cp "$file_list" "$bak"

  $EDITOR $file_list

  i=0
  while read f; do 
    i=$((i+1))
    nf=$(sed -n ${i}p $file_list)
    if [ -e "$nf" ]; then
      continue
    fi
    mv "$f" "$nf"
  done < $bak
}


# 功能: 按照文件創建時間重命名文件
# 依賴: 
#   - mdls: 用於讀取文件元數據, 獲取文件創建時間
function with_date() {
  for f in *; do
    t=$( mdls -name kMDItemContentCreationDate  "$f" | awk '{gsub(":", "", $4); printf "%s-%s\n", $3, $4}' )
    sub=${f##*.}
    echo "$f  ->  $t.$sub"
    mv "$f" "$t.$sub"
  done
}


# main
case $1 in
  date)
    with_date ${@:2}
    ;;
  index)
    with_index ${@:2}
    ;;
  bulk)
    with_bulk ${@:2}
    ;;
  *)
    echo "unknow subcommand $1" >& 2
esac

